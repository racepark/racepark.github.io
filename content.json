{"pages":[],"posts":[{"title":"Vanilla Js 30 - 04~05","text":"04. Array Cardio Day 1Array 기본 메서드를 활용하여 제공 된 데이터를 변경한다. filterArray.prototype.filter()특정 조건에 맞는 요소들을 골라 낼 때1234567const fifteen = inventors.filter(function(inventor){ if(inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt;= 1600){ return true; }});// ES2015const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt;= 1600)); mapArray.prototype.map()요소를 일괄적으로 수정할 때, 전체 배열 값을 이용해서 새로운 배열을 만든다.12345const fullNames = inventors.map(function(inventor){ return inventor.first +' '+inventor.last;});// ES2015const fullNames = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`); sortArray.prototype.sort()조건에 따라 배열을 재정렬.조건에 따른 결과값이 음수면 순서가 바뀌지 않고 양수면 순서가 바뀜.12345const ordered = inventors.sort(function(a, b){ return a.year &gt; b.year ? 1 : -1;});// ES2015const ordered = inventors.sort((a,b) =&gt; (a.year &gt; b.year) ? 1 : -1); reduceArray.prototype.reduce()각 요소에 리듀서함수(reducer Func)를 실행하고, 하나의 결과값을 반환한다.리듀서함수는 (누적값, 현재값, 현재인덳, 원본배열)을 인자값으로 가진다.reduce(reducer, 초기값)1234567const transportation = data.reduce(function(obj, item){ if(!obj[item]){ obj[item] = 0; } obj[item]++; return obj;},{}); 그 외12345// 배열의 요소에 담겨서 각각 변수값으로 사용 가능const [aLast, aFirst] = lastOne.split(', ');// Array.from() 유사 배열 객체, 순회 가능 한 객체일 경우에 새 Array 생성const links = Array.from(category.querySelectorAll('a'));const links = [...category.querySelectorAll('a')]; // ES2015 05. Flex Panel Galleryflexbox로 구성 된 레이아웃에 class 제어를 통해 transition 효과를 준다. 12345678910111213141516function toggleOpen(){ // IE // Does not have support for classList on SVG or MathML elements. // Does not support the second parameter for the toggle method // Does not support multiple parameters for the add() &amp; remove() methods // Does not support assign to classList or the replace() method this.classList.toggle('open');}function toggleActive(e){ console.log(e.propertyName); // Safari transitionend event.propertyName === flex // Chrome + FF transitionend event.propertyName === flex-grow if(e.propertyName.includes('flex')){ this.classList.toggle('open-active'); }} forEachArray​.prototype​.for​Each()각 요소에 함수 실행. 반환 값이 없다.123456panels.forEach(function(panel){ panel.addEventListener('click', toggleOpen);});// ES2015panels.forEach(panel =&gt; panel.addEventListener('click', toggleOpen));panels.forEach(panel =&gt; panel.addEventListener('transitionend', toggleActive));","link":"/2019/05/02/Vanilla-Js-30-04-05/"},{"title":"Vanilla Js 30 - 01","text":"javascript30 : https://javascript30.com/git : https://github.com/wesbos/JavaScript30 이번에 시작하는 FE study를 통해 알게 된 강좌이다. 영알못이다 보니, 무슨 얘기를 하는 지 못알아 듣는 다는 게 함정이다. 하지만, 그래도 짤막짤막하게 들리는 단어들과 영상을 보면서 충분히 코드를 공부 할 수 있기 때문에 큰 문제는 없다.강좌를 진행해가면서 ES2015 문법에 익숙해지는게 목표이다. :)영상을 볼 때마다 나온 ES2015문법을 간단하게 정리하자. 01. JavaScript Drum Kit키보드 알파벳에 따라 오디오 소리가 다르게 나며, 화면에 키보드를 누른 듯한 효과를 준다. 123456&lt;div data-key=\"65\" class=\"key\"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class=\"sound\"&gt;clap&lt;/span&gt;&lt;/div&gt;&lt;audio data-key=\"65\" src=\"sounds/clap.wav\"&gt;&lt;/audio&gt; const / 템플릿문자열123var audio = document.querySelector('audio[data-key=\"'+e.keyCode+'\"]');//ES2015const audio = document.querySelector(`audio[data-key=\"${e.keyCode}\"]`); var키워드 밖에 없었지만 let과 const 키워드가 추가되었다. var의 scope는 함수 단위지만, let과 const는 블럭 단위로 지원한다.const는 상수. 선언시에 초기값을 생략하면 안돼고, 값의 재할당이 불가하다.변수와 문자열 결합시 +기호가 아닌 백틱(`)을 사용한 템플릿 문자열(${})이 사용 가능하다. Arrow function12345keys.forEach(function(key){ return key.addEventListener('transitionend', removeTransition);});//ES2015keys.forEach(key =&gt; key.addEventListener('transitionend', removeTransition)); function(매개변수) {} 에서 (매개변수) =&gt; {} () =&gt; 매개변수가 없을경우 x =&gt; 매개변수가 1개 (x,y) =&gt; 매개변수 여러개익명 함수로만 사용할 수 있기 때문에, 호출하기 위해서는 함수 표현식을 사용한다.","link":"/2019/04/25/Vanilla-Js-30-01/"},{"title":"Vanilla Js 30 - 06","text":"06. Type AheadAPI를 사용하여 도시,주 검색 기능을 만든다. 이번 내용은 내가 다루지않는 것들에 대한 내용들이 여서 이해하기가 어려웠다.지난번엔 시간에 쫓겨 대충 들을 때보단 포스팅하기 위해 정리하며 차분히 따라하다보니어느 정도 나온 내용들이 조금 이해가 되긴했지만,ㅠ 역시나 난해한 내용이다. JSON Fetch_API 123const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';fetch(endpoint).then(blob =&gt; blob.json()) // fetch가 종료된 뒤 데이터가 완전히 넘어온 뒤에 함수 호출 Body.json() 비동기이며 PromiseJavaScript 객체로 해석 되는 객체를 반환한다.JSON.parse() 는 문자열을 JSON으로 파싱한다. 이 문자열은 유효한 JSON 형태의 문자열이어야 하며, 유효하지 않을 경우 에러가 발생한다. Spread_syntax12345678const cities = [];fetch(endpoint).then(blob =&gt; blob.json())// 참조없는 배열복사를 위한 slice 메서드 사용 불가능(let은 가능).then(blob =&gt; Array.prototype.push.apply(cities, data)); // ES2015.then(data =&gt; cities.push(...data)); let은 값의 재할당이 가능하지만, const는 초기값 설정 후 값 재할당이 불가능하다.일반적으로 배열의 엘리먼트를 함수의 인수로 사용하고자 할 때 Function.prototype.apply 를 사용한다. spred 구문을 사용하면 apply 대체가 가능하다. 정규표현식특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다. 1234567891011121314151617// 가져온 데이터에서 input에 입력된 단어를 포함하는 도시나 주 표시function findMatches(wordToMatch, cities){ return cities.filter(place =&gt; { const regex = new RegExp(wordToMatch, 'gi'); // 문자열전체에서 일치하는 문자(열) 반환, 대소문자 구분없이 return place.city.match(regex) || place.state.match(regex); });}// 세자리수 콤마 삽입function numberWithCommas(x) { return x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');}// input에 입력된 단어에 하이라이트 표시const regex = new RegExp(this.value, 'gi');const cityName = place.city.replace(regex, `&lt;span class=\"hl\"&gt;${this.value}&lt;/span&gt;`);const stateName = place.state.replace(regex, `&lt;span class=\"hl\"&gt;${this.value}&lt;/span&gt;`);","link":"/2019/05/08/Vanilla-Js-30-06/"},{"title":"1주차(2019.04.20)","text":"학습공간 만들기 More info: https://hexo.io/docs/deployment.html 1. Hexo CLI 설치 및 블로그 생성(Node.js 설치 필요) 1234$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install 2. _config.yum 파일 수정2-1. 사이트 정보12345678# Sitetitle: Race's Blogsubtitle:description:keywords:author: raceparklanguage:timezone: 2-2. git 설정123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/racepark/racepark.github.io.git branch: master 3. 테마설치3-1. themes폴더에 테마 설치 해당 폴더를 그대로 내려 받거나 git clone 사용1$ git clone {themes repository} themes/{themes name} 3-2. _config.yml 파일 수정1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 3-3. 배포123$ hexo clean $ hexo generate $ hexo deploy 4. 포스트 작성 후 배포4-1. Create a new post1$ hexo new \"My New Post!\" 4-2. Run server1$ hexo server 4-3. Generate static files1$ hexo generate 4-4. Deploy to remote sites1$ hexo deploy 이전에 jekyll로 블로그를 잠깐 했었는 데, 스터디를 시작하면서 hexo로 다시 세팅해보았다.ruby로 작업 했던 것보다 처음 세팅부터가 더 간단하게 느껴지긴 했다.아직 손 봐야 할 부분도 많고 제대로 알고 사용하는 것도 아니지만,이번 기회로 꾸준히 글도 작성하고 해서 블로그를 활성화 시켜봐야겠다!","link":"/2019/04/29/first-week/"},{"title":"3주차(2019.05.04)","text":"JavaScript Variable Memory Hoisting Function 1. JavaScript Variable Memory https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management 메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다. 필요할때 할당한다. 사용한다. (읽기, 쓰기) 필요없어지면 해제한다. 1-1. 자바스크립트 메모리 생성주기 값을 선언할 때 메모리를 할당한다. 몇 가지 함수 내에서도 호출을 통해 메모리 할당이 일어나며, 몇 가지 메서드도 새로운 값이나 오브젝트를 담기 위해 메모리 할당이 일어난다.*메서드 : 객체의 값이 함수 일 때 이를 메서드라고 한다. 변수나 오브젝트 속성 값을 잃고 쓸때 값 사용이 일어난다. 또, 함수 호출시 함수에 인수를 넘길 때도 일어난다. 자바스크립트는 자동으로 가비지 콜렉션을 수행하므로 더 이상 사용하지 않을 값을 찾아내서 해당 값이 차지하고 있던 메모리를 회수한다. 1-2. 가비지 콜렉션가비지 콜렉터는 어떤 값이 더이상 사용되지 않는지, 사용될 가능성이 있는 값이 무엇인지 추적하여 메모리 회수 대상을 정한다.가비지 콜렉터는 항상 필요없어진 메모리만을 해제하지만 모든 필요없어진 메모리를 해제하는건 아니다. 주로 쓰이는 가비지 콜렉션 알고리즘 표시하고 지우기 참조 카운팅 2. Hoisting https://developer.mozilla.org/ko/docs/Glossary/Hoisting var 키워드가 사용된 선언문이나 함수 선언문(function(){})이 scope의 첫줄로 끌어올려지는 현상을 일컫는다.123456789101112var x = 1; // x 초기화console.log(x + \" \" + y); // '1 undefined'var y = 2;catName(\"Chloe\");function catName(name) { console.log(\"My cat's name is \" + name);}/*위 코드의 결과는: \"My cat's name is Chloe\"*/ let과 const가 hoisting이 발생하지 않는 건 아니다. 두 키워드는 블록 스코프 단위이다.변수가 만들어 지고 TDZ가 생성되고, 변수가 실제 있는 위치에 도달 할 때까지 엑세스 할 수 없다.*TDZ : 일시적 사각지대(Temporal Dead Zone; TDZ) 123456let name = 'Chloe'; console.log(name) // Chloe{ console.log(name) // ReferenceError: Cannot access 'name' before initialization let name = 'Chloe';} https://poiemaweb.com/es6-block-scope 3. Function https://poiemaweb.com/js-function 함수란 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록이다.자바스크립트의 함수는 일급 객체이다. 12345678910111213141516// 함수 선언 : 호이스팅 됨 함수가 중복될수 있으므로 지양함 function(){}// 기명 함수 표현식 : 재귀목적으로 사용될 경우 많이 사용함const FN = function name(){};// 익명 함수 표현식const FN2 = function (){};// IIFE : 스코프 오염 시키지 않기 위해 레거시한 환경(function(){})(); 3-1. 반환값 return 문으로 값을 반환 할 수 있다. return문이 없을 경우에는 undefined를 반환한다. 모든 함수는 값을 반환하며, 함수 자체가 값이 된다. 3-2. 매개변수 Argument : 전달해주는 값 Parameter : 전달 된 값은 받아들이는 변수 1234let r1 = sum(10, 20);function sum(x, y) { return x + y;} 3-3. 순수함수어떤 외부 상태도 변경하지 않고, 부수효과가 없는 함수를 칭한다.*부수효과 : side effect, 외부의 상태를 변경하는 것 또는 함수로 들어오는 인자를 직접 변경하는 것 1234567891011// 비순수 함수(Impure function)let a = 1;let b = 3;function sum(a, b) { return a + b;}// 순수함수(Pure function)let r1 = sum(10, 20);function sum(x, y) { return x + y;}","link":"/2019/05/09/third-week/"},{"title":"2주차(2019.04.27)","text":"JS Basic Grammar Type (Primitive, Reference) Value, Expression, Statement Truthy &amp; Falsy 1. JavaScript History https://wit.nts-corp.com/2014/08/13/1925 https://helloworldjavascript.net/pages/100-javascript.html https://ko.wikipedia.org/wiki/javascript 2. Value, Expression, Statement2-1. 값(Value)만들고 변경할 수 있는 데이터, 형(Type)을 표현하는 수단모든 값은 타입을 가지며 타입은 값의 종류를 포함하는 더 큰 개념으로 확장된다. 값의 종류 숫자 - Number 문자열 - String 논리값 - Boolean 값이 정의되지 않은 - undefined 값이 없는 - Null 숫자가 아닌 - NaN 심볼 - Symbol 객체 - Object 2-2. 식(Expression)하나의 값으로 표현된다. https://www.bsidesoft.com/?p=760 *리터럴 : 더 이상 나눌 수 없는 값. 2-3. 문(Statement)의미상 한줄 한줄 각각의 명령, 지시문. 문은 파싱된 이후에 아무것도 남지 않게 되므로 값으로 쓸 수 없다. (Return을 할수 있는건 값, 식)ex. 조건문, 반복문, 제어문, 식 문, 변수선언문 … 3. Type (Primitive, Reference)3-1. 기본값(Primitive)참조되지 않고 복제되며 immutable한 자료형 string number boolean undefined null NaN 3-2. 참조값(Reference)복제되지 않고, 원본은 하나만 유지된 상태로, 주소만 공유되는 것(함수, 객체, 배열)초기값을 설정할 때 해당 값의 메모리를 할당 받고, 값을 사용 할 때나 함수 호출 시 할당된 메모리를 읽고 쓰기만 한다. https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures https://weicomes.tistory.com/133 https://poiemaweb.com/js-immutability 4. Truthy &amp; Falsyboolean 타입이 와야 하는 자리에 다른 타입의 값이 와도 실행되는 데 true로 되는 어떤 값들을 truthy, false로 취급 되는 어떤 값들을 falsy라고 부른다.false, null, undefined, 0, NaN, ‘’(빈문자열)을 제외한 모든 값들은 truthy이다. https://developer.mozilla.org/ko/docs/Glossary/Truthy","link":"/2019/04/30/second-week/"},{"title":"Vanilla Js 30 - 07","text":"07 - Array Cardio Day 24강의 Array Cardio Day 1와 이어지는 내용이다.Array의 기본 메서드 활용편 2. someArray.prototype.some()요소 중에 주어진 판별 함수에 맞는 게 있는지 확인.true 값일 때까지 각 요소에 callback 함수를 실행하고, true일 때 루프 정지 반환. (find(), findIndex() 동일)123const isAdult = people.some(person =&gt; { return (new Date()).getFullYear() - person.year &gt;= 19}); everyArray.prototype.every()요소 전체가 주어진 판별 함수에 맞는지 확인.false 값일 때까지 각 요소에 callback 함수를 실행하고, false일 때 루프 정지 반환.123const allAdult = people.every(person =&gt; { return (new Date()).getFullYear() - person.year &gt;= 19}); findArray.prototype.find()주어진 판별 함수에 맞는 첫 번째 요소의 값 반환.1const comment = comments.find(comment =&gt; comment.id === 823423); findIndexArray.prototype.find​Index()주어진 판별 함수에 맞는 첫 번째 요소의 인덱스 반환.1const index = comments.findIndex(comment =&gt; comment.id === 823423); spliceArray​.prototype​.splice()요소를 삭제, 교체, 추가하여 배열내용 변경. array.splice(start[, deleteCount[, item1[, item2[, …]]]]) start : 시작인덱스 deleteCount : 삭제할 요소수 item1, item2, … : 추가 될 요소 1comments.splice(index, 1); sliceArray​.prototype​.slice()시배열의 얕은 복사본을 새로운 배열 객체로 반환. 원본 배열은 수정되지 않는다.123456789101112let arr = [1,2,3];let arr2 = arr;arr2.push(4); console.log(arr) // [1, 2, 3, 4]let arr3 = arr.slice();// ES2015let arr3 = [...arr]; // Spread 문법은 배열을 복사할 때 1 레벨 깊이에서 효과적으로 동작arr3.push(5);console.log(arr3) // [1, 2, 3, 4, 5]console.log(arr) // [1, 2, 3, 4] 123456789101112131415161718const comments = [ { text: 'Love this!', id: 523423 }, { text: 'Super good', id: 823423 }, { text: 'You are the best', id: 2039842 }, { text: 'Ramen is my fav food ever', id: 123523 }, { text: 'Nice Nice Nice!', id: 542328 }];// 만들어진 배열이 들어감let newComments = [ comments.slice(0, 1)];console.log(newComments); // [Array(1)]// 만들어진 배열의 요소들이 들어감let newComments = [ ...comments.slice(0, 1) ];console.log(newComments); // [{…}]","link":"/2019/05/11/Vanilla-Js-30-07/"},{"title":"Vanilla Js 30 - 02~03","text":"02. JS and CSS ClockDate 객체를 이용하여 시계바늘을 돌아가게 만든다. 1234567&lt;div class=\"clock\"&gt; &lt;div class=\"clock-face\"&gt; &lt;div class=\"hand hour-hand\"&gt;&lt;/div&gt; &lt;div class=\"hand min-hand\"&gt;&lt;/div&gt; &lt;div class=\"hand second-hand\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910const now = new Date();// 초를 가져온다.const seconds = now.getSeconds();const secondsDegree = seconds / 60 * 360 + 90;secondHand.style.transform = `rotate(${secondsDegree}deg)`;// 분을 가져온다.const mins = now.getMinutes();// 1초 마다 setDate함수를 반복 호출setInterval(setDate, 1000); 03. CSS VariablesCSS 커스텀 속성을 활용한다. 1234567891011:root { --base: yellow; --spacing: 10px; --blur: 10px;}img{ padding: var(--spacing); background: var(--base); filter: blur(var(--blur));} 123456// data 속성 사용(dataset은 IE11부터, 10이하는 getAttribute() 사용)const suffix = this.dataset.sizing || '';// 각 input의 value를 &lt;html&gt;의 CSS CUSTOM 속성값으로 할당document.documentElement.style.setProperty(`--${this.name}`, this.value + suffix);input.forEach(input =&gt; input.addEventListener('change', handleUpdate)); 작성자가 정의하는 속성의 집합인 --var-name.(사용: var(var-name))HTML 요소에 추가적으로 데이터를 저장할 수 있게 해주는 data-*.커스텀 속성을 스크립트에서 유용하게 사용하기.","link":"/2019/04/26/Vanilla-Js-30-02-03/"},{"title":"Vanilla Js 30 - 08","text":"08 - Fun with HTML5 Canvascanvas에 mouse event를 활용하여 선을 그린다. 참조 기본 사용법 스타일과 색 적용하기 도형 그리기 도형 합성 HSL : HSL은 색조(hue), 포화(saturation), 밝기(lightness)로 컬러를 표현하는 방법으로 사람이 색을 묘사하는 방법과 유사한 속성을 사용하기 때문에 비슷한 색이나 약간의 변화가 필요한 색을 조합할 때 직관적으로 색을 만들어낼 수 있다. 캔버스 생성1&lt;canvas id=\"draw\" width=\"800\" height=\"800\"&gt;&lt;/canvas&gt; 123const canvas = document.getElementById('draw');// 랜더링 컨텍스트와 (렌더링 컨텍스트의) 그리기 함수들을 사용할 수 있게 해주는 메서드 getContext(contextType)const ctx = canvas.getContext('2d'); 캔버스 속성12345678910// 윤곽선 색ctx.strokeStyle = '#BADA55'; // 연결되는 지점의 모양ctx.lineJoin = 'round'; // 선의 끝 모양ctx.lineCap = 'round'; // 선의 굵기ctx.lineWidth = 100; //새로운 도형을 그릴 때, 도형 합성 방법을 설정ctx.globalCompositeOperation = 'multiply'; 캔버스 메서드12345678// 새로운 경로 생성, 이후 그리기 명령들은 경로를 구성하고 만드는데 사용ctx.beginPath(); // 펜을 x와 y 로 지정된 좌표로 옮김. ctx.moveTo(lastX, lastY); // 현재의 드로잉 위치에서 x와 y로 지정된 위치까지 선을 그림.ctx.lineTo(e.offsetX, e.offsetY); // 윤곽선을 그림ctx.stroke(); 마우스 이벤트1234567891011// 마우스를 움직일 때canvas.addEventListener('mousemove', draw);// 마우스 버튼을 누를 때canvas.addEventListener('mousedown', (e) =&gt; { isDrwing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});// 마우스 버튼을 뗄 때canvas.addEventListener('mouseup', () =&gt; isDrwing = false);// 마우스가 요소를 벗어날 때canvas.addEventListener('mouseout', () =&gt; isDrwing = false);","link":"/2019/05/11/Vanilla-Js-30-08/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"FEstudy","slug":"FEstudy","link":"/tags/FEstudy/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"FEstudy","slug":"TIL/FEstudy","link":"/categories/TIL/FEstudy/"},{"name":"javascript30","slug":"TIL/javascript30","link":"/categories/TIL/javascript30/"}]}